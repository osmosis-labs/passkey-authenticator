use base64::{engine::general_purpose::URL_SAFE_NO_PAD, Engine as _};
use cosmwasm_std::Binary;
use p256::ecdsa::{signature::Signer, SigningKey};
use p256::ecdsa::{Signature, VerifyingKey};
// use rand::Rng;
use serde::{Deserialize, Serialize};
use serde_json::json;
use sha2::{Digest, Sha256};
use std::fs::File;
use std::io::Write;

fn generate_challenge() -> Vec<u8> {
    let challenge_string = "message";
    challenge_string.as_bytes().to_vec()
}

fn create_client_data_json(challenge: &[u8]) -> String {
    let client_data = json!({
        "type": "webauthn.get",
        "challenge": URL_SAFE_NO_PAD.encode(challenge),
        "origin": "https://example.com"
    });
    client_data.to_string()
}

fn create_authenticator_data() -> Vec<u8> {
    // This is a placeholder. In a real implementation, this would be generated by the authenticator.
    vec![0u8; 37]
}

/// The signature and public key are in "Cosmos" format:
/// - signature:  Serialized "compact" signature (64 bytes).
/// - public key: [Serialized according to SEC 2](https://www.oreilly.com/library/view/programming-bitcoin/9781492031482/ch04.html)
///   (33 or 65 bytes), which is compliant with the X9.62 standard.
fn create_keypair_and_signature(message_hash: &[u8]) -> (Vec<u8>, Vec<u8>) {
    let signing_key = SigningKey::random(&mut rand::thread_rng());
    let signature: Signature = signing_key.sign(message_hash);
    let verifying_key = VerifyingKey::from(&signing_key);
    // Ensure the public key is uncompressed (65 bytes) or compressed (33 bytes)
    let public_key = verifying_key.to_encoded_point(false); // false for uncompressed
    let public_key_bytes = if public_key.is_compressed() {
        public_key.as_bytes().to_vec() // Compressed, 33 bytes
    } else {
        public_key.as_bytes()[..65].to_vec() // Uncompressed, 65 bytes
    };
    let signature_bytes = signature.to_vec(); // Use compact format (64 bytes)
    (public_key_bytes, signature_bytes)
}

#[derive(Serialize, Deserialize)]
struct WebAuthnTestData {
    authenticator_data: Binary, // Typically a byte array
    client_data_json: Binary,   // JSON formatted string
    challenge: Binary,          // Raw challenge bytes
    signature: Binary,          // DER-encoded ECDSA signature
    public_key: Binary,         // X9.62 encoded public key
}

// Instructions for decoding and verifying the data from the file:
// 1. The file is stored in JSON format at 'testdata/verify_webauthn_assertion_tests.json'.
// 2. Utilize a JSON parser to read and convert the JSON data into the WebAuthnTestData structure.
// 3. Verify that the JSON keys correspond to the fields in the WebAuthnTestData structure:
//    - 'authenticator_data' should be a Base64 URL encoded byte array.
//    - 'client_data_json' should be a UTF-8 encoded string.
//    - 'challenge' should be raw challenge bytes.
//    - 'signature' should be a DER-encoded ECDSA signature in byte array format.
//    - 'public_key' should be an X9.62 encoded public key in byte array format.
// 4. Handle any potential errors during parsing to prevent crashes or data corruption, ensuring robust error handling and reporting.
fn main() {
    // Generate valid test data
    let challenge = generate_challenge();
    let client_data_json = create_client_data_json(&challenge);

    let authenticator_data = create_authenticator_data();

    // Compute the client data JSON hash
    let client_data_json_hash = Sha256::digest(client_data_json.as_bytes());

    // Compute the message hash
    let message_hash =
        Sha256::digest(&[&authenticator_data[..], &client_data_json_hash[..]].concat());

    // Generate a keypair and sign the data
    let (public_key, signature) = create_keypair_and_signature(&message_hash);

    let data = WebAuthnTestData {
        authenticator_data: Binary(authenticator_data),
        client_data_json: Binary(client_data_json.into_bytes()),
        challenge: Binary(challenge), // Store raw challenge bytes
        signature: Binary(signature),
        public_key: Binary(public_key),
    };

    // Serialize the data into JSON format
    let json_data = serde_json::to_string(&data).expect("Failed to serialize data");

    // Create a new file to store the serialized data
    let mut file = File::create("testdata/verify_webauthn_assertion_tests.json")
        .expect("Failed to create file");

    // Write the JSON data to the file
    file.write_all(json_data.as_bytes())
        .expect("Failed to write to file");
}
